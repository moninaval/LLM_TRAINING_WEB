<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>loss.backward() — Gradient Flow Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#ffffff; --paper:#fafafa; --ink:#0b1220; --muted:#5b657a;
      --rule:#e5e7eb; --accent:#2563eb; --accent2:#0891b2;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg); color:var(--ink);
         font:14px/1.5 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";}
    .container{max-width:1600px;margin:0 auto;padding:20px}
    .title{border:1px solid var(--rule); border-radius:12px; background:var(--paper);
           padding:14px 16px; text-align:center; margin-bottom:16px}
    .title h1{margin:0; font-size:22px; letter-spacing:.2px}
    .progress{height:3px; background:#f0f2f6; border-radius:999px; overflow:hidden; margin:10px auto 16px; max-width:560px;}
    .progress::after{content:""; display:block; height:100%; width:40%;
      background:linear-gradient(90deg, var(--accent), var(--accent2));
      animation:load 1.05s linear infinite; border-radius:999px}
    @keyframes load{0%{transform:translateX(-120%)}100%{transform:translateX(320%)}}

    /* Two columns: left = gradient tree, right = main flow */
    .layout{display:grid; grid-template-columns: 1.1fr 1fr; gap:16px}

    .card{background:#fff; border:1px solid var(--rule); border-radius:12px; padding:14px}
    .card h2{margin:0 0 10px 0; font-size:18px; letter-spacing:.2px}
    .smallnote{font-size:12px; color:var(--muted); margin:6px 0 10px}

    /* Tabs */
    .tabs{display:flex; gap:8px; flex-wrap:wrap; margin:8px 0 10px}
    .tab{padding:6px 10px; border-radius:10px; background:#eef2ff; border:1px solid #dbe3ff; color:#173785; cursor:pointer; font-size:13px}
    .tab.active{background:#2563eb; color:#fff; border-color:#2563eb}
    /* ensure clicks always register */
    .tabs, .tab { pointer-events:auto; }

    /* Flow sections */
    .flow-card{border-left:3px solid var(--accent); padding-left:12px; margin:14px 0 16px}
    .matrix{font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
            background:#fbfcff; border:1px solid #e6ecff; color:#0b1220;
            padding:8px; border-radius:8px; overflow-x:auto; white-space:pre}
    .scroll-box{max-height:380px; overflow:auto}
    details{margin-top:8px}
    summary{cursor:pointer}

    /* Gradient Tree styles (light, paper-like) */
    #gradTree .gt-wrap{display:grid;grid-template-columns:1fr;gap:10px}
    #gradTree .gt-canvas{position:relative;min-height:720px;background:#fff;border:1px solid var(--rule);border-radius:12px;padding:18px;overflow:auto}
    #gradTree .gt-details{background:#fff;border:1px solid var(--rule);border-radius:12px;padding:12px}
    #gradTree .gt-node{
      position:absolute; min-width:160px; max-width:240px; padding:8px 10px; border-radius:10px;
      background:#ffffff; border:1px solid #e5e7eb; color:#0b1220; font:13px/1.35 system-ui;
      box-shadow:0 1px 0 rgba(0,0,0,.05);
      cursor:pointer; transition:transform .05s ease;
    }
    #gradTree .gt-node:hover{transform:translateY(-1px)}
    #gradTree .gt-node .title{font-weight:700; font-size:13px; color:#0b1220}
    #gradTree .gt-node .sub{color:#45506a}
    #gradTree .gt-node .shape{color:#0b3e8a; font-family:ui-monospace,Menlo,Consolas,monospace}
    #gradTree .gt-link{position:absolute; pointer-events:none}
    #gradTree .chip{display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; border:1px solid #dbe3ff; color:#173785; font-size:11px}
    #gradTree .mono{font-family:ui-monospace,Menlo,Consolas,monospace; color:#0b1220}
    #gradTree .muted{color:#5b657a}
    #gradTree h3{margin:.2rem 0 .4rem 0; font-size:14px; color:#0b1220}
    #gradTree pre{background:#fbfcff; border:1px solid #e6ecff; color:#0b1220; padding:8px; border-radius:8px; overflow:auto; white-space:pre-wrap}
  </style>
</head>
<body>
  <div class="container">
    <div class="title">
      <h1><span class="mono">loss.backward()</span> — Gradient Flow Explorer</h1>
      <div class="smallnote">From logits down to Q/K/V and Wq, visualized like a paper figure.</div>
    </div>

    <div id="globalProgress" class="progress"></div>

    <div class="layout">
      <!-- LEFT: Gradient Flow Tree (big canvas) -->
      <div class="card" id="gradTree">
        <h2>Gradient Flow Tree loss.backward()</h2>
        <div class="smallnote">Click nodes to see forward formula and backward rule.</div>
        <!-- the widget will render here -->
      </div>

      <!-- RIGHT: Main content (X → Wq → Head tabs → ∇Wq) -->
      <div id="flow" class="card">
        <h2>Main Flow (Query path)</h2>
        <p class="smallnote">Q = X · Wq → S = (QKᵀ)/√d → A=softmax(S) → C = A · V → Concat · W_O → logits</p>
        <div class="matrix">Loading…</div>
      </div>
    </div>
  </div>
<script>
function renderParamMinimal(obj){
  const pname = obj?.parameter_name || "Wq";
  const fused = /qkv/i.test(pname);
  const label = fused ? `${pname} (Query slice of fused QKV)` : pname;
  return `
    <div class="note-card">
      <div><strong>Example Gradient focus:</strong> <span class="mono">${label}</span></div>
      <div style="font-size:13px; color:#45506a; margin-top:4px">
        Computed by <span class="mono">∇Wq = Xᵀ · ∇Q</span> during <span class="mono">loss.backward()</span>.
        Values shown below are for <em>this parameter only</em> (current step).
      </div>
    </div>`;
}
</script>

  <script>
    const LOSS_ENDPOINT  = "/loss";
    const PARAM_ENDPOINT = "/param_wq";

    // ------- helpers to find objects in nested JSON -------
    function looksLikeLoss(o){return o && typeof o==='object' && (('loss' in o)||('step' in o));}
    function looksLikeParam(o){return o && typeof o==='object' && ('parameter_name' in o);}
    function deepFind(root, pred, depth=0, maxDepth=10){
      if (!root || depth>maxDepth) return null;
      if (pred(root)) return root;
      if (Array.isArray(root)) { for (const el of root){ const hit=deepFind(el,pred,depth+1,maxDepth); if (hit) return hit; } return null; }
      if (typeof root==='object'){ for (const k of Object.keys(root)){ const hit=deepFind(root[k],pred,depth+1,maxDepth); if (hit) return hit; } }
      return null;
    }

    // ------- pretty renderers (book-style) -------
    function previewRows(seq, rows=2, cols=8){
      return (seq||[]).slice(0,rows).map((tok,ti)=>`Token ${ti}: `+(tok||[]).slice(0,cols).map(n=>typeof n==="number"? n.toFixed(3): n).join(" ")).join("\n");
    }

    function renderInputX(X){
      if(!X) return `<div class="flow-card"><p class="smallnote">No X found.</p></div>`;
      const dModel = X?.[0]?.[0]?.length ?? 'd_model';
      let html = `<div class="flow-card">
        <h3>Input X — Sequence Embeddings</h3>
        <p class="smallnote">Each sequence has T tokens; each token is a <b>${dModel}</b>-dimensional vector (d_model). Expand to inspect tokens.</p>`;
      X.forEach((seq, si)=>{
        const T = seq?.length ?? '?';
        const prev = previewRows(seq);
        html += `
          <details>
            <summary><b>Sequence ${si}</b> — ${T} tokens</summary>
            <div class="matrix">Preview (first 2 tokens × 8 dims)
${prev}${T>2? "\n..." : ""}</div>
            <details>
              <summary>Token-wise (segmented rows)</summary>
              <div class="scroll-box">
                ${seq.map((tok,ti)=>{
                  const rowPrev=(tok||[]).slice(0,8).map(v=>typeof v==="number"? v.toFixed(3): v).join(" ");
                  return `<details><summary>Token ${ti} — first 8 dims: <span class="mono">${rowPrev}</span> …</summary>
                            <div class="matrix">${JSON.stringify(tok)}</div>
                          </details>`;
                }).join("")}
              </div>
            </details>
          </details>
        `;
      });
      html += `</div>`;
      return html;
    }

    function renderWq(Wq, numHeads=8){
      if(!Wq) return `<div class="flow-card"><p class="smallnote">No Wq found.</p></div>`;
      const dModel = Wq.length, dHead = Math.floor(dModel / numHeads);
      const topLeft = Wq.slice(0,5).map(r=>r.slice(0,8).map(v=>v.toFixed(3)).join(" ")).join("\n");
      let html = `<div class="flow-card">
        <h3>Projection Matrix Wq</h3>
        <p class="smallnote">Shape: <b>[${dModel} × ${dModel}]</b>. Partition columns into <b>${numHeads}</b> blocks of size <b>[${dModel} × ${dHead}]</b> (one per head). Formula: <span class="mono">Q = X · Wq</span>.</p>
        <div class="matrix">Preview (top-left 5×8)
${topLeft}
        </div>
        <details>
          <summary>Head-wise column blocks</summary>
          <div class="scroll-box">
            ${Array.from({length:numHeads}).map((_,h)=>{
              const c0=h*dHead, c1=c0+dHead;
              const block = Wq.slice(0,5).map(r=>r.slice(c0, Math.min(c1,c0+8)).map(v=>v.toFixed(3)).join(" ")).join("\n");
              return `<details><summary>Head ${h} — columns [${c0}:${c1})</summary>
                        <div class="matrix">Rows 0..4 × first 8 cols of head ${h}
${block}
                        </div>
                      </details>`;
            }).join("")}
          </div>
        </details>
      </div>`;
      return html;
    }

    function renderQHead(Q2D, h){
      if(!Q2D) return '';
      const T=Q2D.length, dHead=(Q2D?.[0]?.length ?? '?');
      const prev = Q2D.slice(0,3).map((tok,ti)=>"Token "+ti+": "+tok.slice(0,8).map(v=>v.toFixed(3)).join(" ")).join("\n");
      return `<div class="flow-card">
        <h3>Projected Queries Q — Head ${h}</h3>
        <p class="smallnote">Shape: <b>[${T} × ${dHead}]</b>. Produced by <span class="mono">Q = X · Wq</span> then reshaped into heads.</p>
        <details open><summary>Preview (first 3 tokens × 8 dims)</summary>
          <div class="matrix">${prev}${T>3? "\n..." : ""}</div>
        </details>
        <details>
          <summary>Full Q by tokens (${T})</summary>
          <div class="scroll-box">
            ${Q2D.map((tok,ti)=>{
              const rowPrev=tok.slice(0,8).map(v=>v.toFixed(3)).join(" ");
              return `<details><summary>Token ${ti} — first 8 dims: <span class="mono">${rowPrev}</span> …</summary>
                        <div class="matrix">${JSON.stringify(tok)}</div>
                      </details>`;
            }).join("")}
          </div>
        </details>
      </div>`;
    }

    function renderDLdQHead(D2D, h){
      if(!D2D) return '';
      const T=D2D.length, dHead=(D2D?.[0]?.length ?? '?');
      const prev = D2D.slice(0,3).map((tok,ti)=>"Token "+ti+": "+tok.slice(0,8).map(v=>v.toFixed(3)).join(" ")).join("\n");
      return `<div class="flow-card">
        <h3>Gradient w.r.t Q (∂L/∂Q) — Head ${h}</h3>
        <p class="smallnote">Shape: <b>[${T} × ${dHead}]</b>. Using <span class="mono">gS = (gA − ⟨gA,A⟩) ⊙ A</span> and <span class="mono">gQ = gS · K / √d</span>.</p>
        <details open><summary>Preview (first 3 tokens × 8 dims)</summary>
          <div class="matrix">${prev}${T>3? "\n..." : ""}</div>
        </details>
        <details>
          <summary>Full ∂L/∂Q by tokens (${T})</summary>
          <div class="scroll-box">
            ${D2D.map((tok,ti)=>{
              const rowPrev=tok.slice(0,8).map(v=>v.toFixed(3)).join(" ");
              return `<details><summary>Token ${ti} — first 8 dims: <span class="mono">${rowPrev}</span> …</summary>
                        <div class="matrix">${JSON.stringify(tok)}</div>
                      </details>`;
            }).join("")}
          </div>
        </details>
      </div>`;
    }

    function renderGradWq(grad){
      if(!grad) return `<div class="flow-card"><p class="smallnote">No ∇Wq found.</p></div>`;
      const H = grad.length, W = grad?.[0]?.length ?? '?';
      const tl = grad.slice(0,5).map(r=>r.slice(0,8).map(v=>v.toFixed(3)).join(" ")).join("\n");
      return `<div class="flow-card">
        <h3>Gradient of Wq (∇Wq)</h3>
        <p class="smallnote">Shape: <b>[${H} × ${W}]</b>. Formula: <span class="mono">∇Wq = Xᵀ · ∇Q</span>. Each element: <span class="mono">∂L/∂Wq[i,j] = Σₜ X[t,i] · ∂L/∂Q[t,j]</span>.</p>
        <div class="matrix">Preview (top-left 5×8)
${tl}
        </div>
      </div>`;
    }

    // ------- Loaders -------
    let PARAM_OBJ = null, LOSS_OBJ = null;
    let loadedPieces = 0;
    function pieceLoaded(){ if(++loadedPieces >= 2){ const gp=document.getElementById('globalProgress'); if(gp) gp.style.display='none'; } }

    async function loadLoss(){
      try{
        const res = await fetch(LOSS_ENDPOINT+`?ts=${Date.now()}`, {cache:'no-store'});
        const payload = await res.json();
        const obj = deepFind(payload, looksLikeLoss) || payload;
        window.LOSS_OBJ = LOSS_OBJ = obj; // expose for tree
      }catch(e){ console.error(e); }
      finally { pieceLoaded(); }
    }

    function buildHeadTabsHTML(numHeads){
      let html = `<div class="tabs" id="headTabs">`;
      for(let h=0; h<numHeads; h++){ html += `<button class="tab" data-head="${h}">Head ${h}</button>`; }
      html += `</div><div id="headContent"></div>`;
      return html;
    }

    function renderHead(h){
      const headContent = document.getElementById('headContent');
      if (!PARAM_OBJ) return;
      const Qh  = PARAM_OBJ?.Q?.[0]?.[h];
      const DQh = PARAM_OBJ?.dLdQ?.[0]?.[h];
      let html = '';
      html += renderQHead(Qh, h);
      html += renderDLdQHead(DQh, h);
      headContent.innerHTML = html || `<p class="smallnote">No data for this head.</p>`;
      // toggle active state
      document.querySelectorAll('#headTabs .tab').forEach(btn=>btn.classList.remove('active'));
      const btn = document.querySelector(`#headTabs .tab[data-head="${h}"]`);
      if (btn) btn.classList.add('active');
    }

    // robust event delegation (fixes "tabs not clickable")
    document.addEventListener('click', (e)=>{
      const btn = e.target.closest('#headTabs .tab');
      if (!btn) return;
      const h = Number(btn.dataset.head);
      if (!Number.isFinite(h)) return;
      renderHead(h);
    });

    async function loadFlow(){
      const flow = document.getElementById('flow');
      try{
        const res = await fetch(PARAM_ENDPOINT+`?ts=${Date.now()}`, {cache:'no-store'});
        const payload = await res.json();
        const obj = deepFind(payload, looksLikeParam) || payload;
        window.PARAM_OBJ = PARAM_OBJ = obj; // expose for tree

        const numHeads = obj.Q?.[0]?.length || 0;

        // Build right column content
        let html = `<div class="smallnote">Step <b>${obj.step ?? 'n/a'}</b>, Loss <b>${(obj.loss ?? 'n/a')}</b>, Param <b>${obj.parameter_name || 'Wq'}</b></div>`;
        html += renderParamMinimal(obj);
        html += renderInputX(obj.X);
        html += renderWq(obj.Wq, numHeads || 8);
        if (numHeads > 0){
          html += `<div class="flow-card"><h3>Head Views</h3>
                     <p class="smallnote">Inspect per-head Q and ∂L/∂Q.</p>
                     ${buildHeadTabsHTML(numHeads)}
                   </div>`;
        }
        html += renderGradWq(obj.grad_Wq);
        flow.innerHTML = html;

        if (numHeads > 0) renderHead(0); // default head

        // Insert Gradient Tree container in the left card and render it
        const treeHost = document.getElementById('gradTree');
        if (treeHost){
          // ensure we have a container div for the widget internals
          const exists = treeHost.querySelector('.gt-wrap');
          if (!exists){
            const d = document.createElement('div');
            d.className = 'gt-wrap';
            d.innerHTML = `<div class="gt-canvas"><svg class="gt-link" width="2200" height="1400"></svg></div>
                           <div class="gt-details"><h3>Node Details</h3><div id="gtInfo" class="smallnote">Click a node…</div></div>`;
            treeHost.appendChild(d);
          }
          // render / refresh the tree
          renderGradTree({ containerId: "gradTree" });
        }

      }catch(e){
        console.error(e);
        flow.innerHTML = `<div class="matrix">Failed to load parameter snapshot.</div>`;
      } finally { pieceLoaded(); }
    }

    // ------- Gradient Tree widget (drop-in, light theme) -------
    (function(){
      function line(svg, x1,y1,x2,y2, color="#2563eb"){
        const p = document.createElementNS("http://www.w3.org/2000/svg","path");
        const mx = (x1+x2)/2;
        const d = `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
        p.setAttribute("d", d); p.setAttribute("fill","none"); p.setAttribute("stroke", color); p.setAttribute("stroke-width","2");
        svg.appendChild(p);
      }
      function makeShapes(cfg){
        const H = cfg?.H ?? (window.PARAM_OBJ?.Q?.[0]?.length ?? 8);
        const d_head = cfg?.d_head ?? (window.PARAM_OBJ?.Q?.[0]?.[0]?.[0]?.length ?? 64);
        const B = cfg?.B ?? (window.LOSS_OBJ?.batch_size ?? 1);
        const T = cfg?.T ?? (window.LOSS_OBJ?.seq_len ?? 128);
        const V = cfg?.V ?? (window.LOSS_OBJ?.vocab_size ?? 50000);
        const d_model = cfg?.d_model ?? (H * d_head);
        return {B,T,V,H,d_head,d_model};
      }
      function treeData(cfg){
        const {B,T,V,H,d_head,d_model} = makeShapes(cfg);
        const N = [
          {id:"loss", x:  40, y:  10,  title:"Cross-Entropy Loss", sub:"L = -log p[y]", shape:"[scalar]"},
          {id:"logits", x: 40, y: 100, title:"Logits", sub:"z", shape:`[B=${B}, T=${Math.max(0,T-1)}, V=${V}]`,
           grad:"∂L/∂z = softmax(z) - one_hot(y)"},
          {id:"vocablin", x: 40, y: 210, title:"Vocab Linear", sub:"z = hidden · W_vocabᵀ + b",
           grad:"∂L/∂hidden = (∂L/∂z) · W_vocab\n∂L/∂W_vocab = (∂L/∂z)ᵀ · hidden\n∂L/∂b = Σ ∂L/∂z"},
          {id:"hidden", x: 40, y: 320, title:"Hidden (LN + Residual + MLP + Attn)", sub:"splits to Attn & MLP", shape:`[B, T-1, d_model=${d_model}]`,
           grad:"Grads add at residual joins"},

          {id:"outproj", x: 400, y: 210, title:"Out Proj (W_O)", sub:"y = Concat · W_Oᵀ",
           grad:"∂L/∂Concat = (∂L/∂y) · W_O\n∂L/∂W_O = (∂L/∂y)ᵀ · Concat"},
          {id:"concat", x: 400, y: 320, title:"Concat Heads", sub:`[B, T-1, H·d_head], H=${H}`,

           grad:"reshape/split grads per head"},

          {id:"C", x: 780, y: 100, title:"Context Cₕ", sub:"C = A · V", shape:`[T-1, d_head=${d_head}]`,
           grad:"∂L/∂A = (∂L/∂C) · Vᵀ\n∂L/∂V = Aᵀ · (∂L/∂C)"},
          {id:"A", x: 780, y: 210, title:"Attention Aₕ", sub:"A = softmax(S) (row-wise)", shape:`[T-1, T-1]`,
           grad:"∂L/∂S = (gA - ⟨gA,A⟩) ⊙ A"},
          {id:"S", x: 780, y: 320, title:"Scores Sₕ", sub:"S = (Q Kᵀ)/√d_head + mask", shape:`[T-1, T-1]`,
           grad:"∂L/∂Q = (∂L/∂S) · K / √d\n∂L/∂K = (∂L/∂S)ᵀ · Q / √d"},

          {id:"Q", x: 1160, y: 100, title:"Qₕ", sub:"Q = X · Wq", shape:`[T-1, d_head]`,
           grad:"∂L/∂Wq = Xᵀ · (∂L/∂Q)\n∂L/∂X += (∂L/∂Q) · Wqᵀ"},
          {id:"K", x: 1160, y: 210, title:"Kₕ", sub:"K = X · Wk", shape:`[T-1, d_head]`,
           grad:"∂L/∂Wk = Xᵀ · (∂L/∂K)\n∂L/∂X += (∂L/∂K) · Wkᵀ"},
          {id:"V", x: 1160, y: 320, title:"Vₕ", sub:"V = X · Wv", shape:`[T-1, d_head]`,
           grad:"∂L/∂Wv = Xᵀ · (∂L/∂V)\n∂L/∂X += (∂L/∂V) · Wvᵀ"},

          {id:"X", x: 1490, y: 210, title:"Block Input X", sub:"from previous layer/embeds", shape:`[T-1, d_model=${d_model}]`,
           grad:"accumulates from Q,K,V paths"}
        ];
        const E = [
          ["loss","logits"],
          ["logits","vocablin"],
          ["vocablin","hidden"],
          ["hidden","outproj"],
          ["outproj","concat"],
          ["concat","C"],
          ["C","A"],
          ["A","S"],
          ["S","Q"], ["S","K"],
          ["Q","X"], ["K","X"],
          ["C","V"], ["V","X"],
        ];
        return {nodes:N, edges:E, meta:{B,T,V,H,d_model,d_head}};
      }

      window.renderGradTree = function renderGradTree(cfg={containerId:"gradTree"}){
        const root = document.getElementById(cfg.containerId);
        if (!root) return;
        const host = root.querySelector('.gt-wrap');
        if (!host) return; // built by loadFlow

        const {nodes, edges, meta} = treeData(cfg);
        const canvas = root.querySelector(".gt-canvas");
        const svg    = root.querySelector("svg");
        const info   = root.querySelector("#gtInfo");
        // reset svg
        while (svg.firstChild) svg.removeChild(svg.firstChild);

        // place nodes
        const nodeEls = {};
        nodes.forEach(n=>{
          const el = document.createElement("div");
          el.className = "gt-node";
          el.style.left = (n.x)+"px";
          el.style.top  = (n.y)+"px";
          el.innerHTML = `
            <div class="title">${n.title}</div>
            <div class="sub">${n.sub || ""}</div>
            ${n.shape ? `<div class="shape mono">${n.shape}</div>` : ""}
          `;
          el.onclick = ()=>{
            info.innerHTML = `
              <div class="chip">${n.title}</div>
              ${n.shape ? `<div style="margin-top:6px"><span class="muted">Shape: </span><span class="mono">${n.shape}</span></div>`:""}
              ${n.sub ? `<div style="margin-top:6px"><span class="muted">Forward: </span><span class="mono">${n.sub}</span></div>`:""}
              ${n.grad ? `<div style="margin-top:6px"><span class="muted">Backward: </span><pre>${n.grad}</pre></div>`:""}
              <div class="smallnote" style="margin-top:6px">B=${meta.B}, T=${Math.max(0,meta.T-1)}, V=${meta.V}, H=${meta.H}, d_head=${meta.d_head}, d_model=${meta.d_model}</div>
            `;
          };
          canvas.appendChild(el);
          nodeEls[n.id]=el;
        });

        // curved links
        function centerRight(el){const r=el.getBoundingClientRect(); const p=canvas.getBoundingClientRect(); return {x:r.left-p.left + r.width, y:r.top-p.top + r.height/2};}
        function centerLeft(el){const r=el.getBoundingClientRect(); const p=canvas.getBoundingClientRect(); return {x:r.left-p.left, y:r.top-p.top + r.height/2};}
        edges.forEach(([from,to])=>{
          const a=nodeEls[from], b=nodeEls[to];
          if(!a||!b) return;
          const A=centerRight(a), B=centerLeft(b);
          line(svg, A.x+6, A.y, B.x-6, B.y);
        });

        nodeEls["logits"]?.click(); // default
      };
    })();

    // ------- Kick off -------
    (async () => {
      await loadLoss();
      await loadFlow();     // builds DOM (including gradTree host) and sets PARAM_OBJ
      // renderGradTree is already called inside loadFlow after DOM insert,
      // but call again here if you want to refresh after both endpoints:
      renderGradTree({ containerId: "gradTree" });
    })();
  </script>
</body>
</html>
