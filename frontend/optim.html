<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LLM Optimization Explorer ðŸŽ¨</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

  <style>
    body { font-family: system-ui, sans-serif; margin: 0; background: #f8fafc; color: #1e2b3b; }
    .container { max-width: 1200px; margin: 24px auto; padding: 0 24px; }
    h1,h2,h3,h4 { color:#0f172a; font-weight:600; }
    h1{font-size:28px;} h2{font-size:20px; border-bottom:1px solid #e2e8f0;}
    .header-intro{background:#fff; border:1px solid #e2e8f0; border-radius:12px; padding:20px; margin-bottom:24px;}
    .main-layout{display:grid; grid-template-columns:350px 1fr; gap:24px;}
    .info-box{background:#fff; border:1px solid #e2e8f0; border-radius:12px; padding:16px;}
    table{border-collapse:collapse;width:100%;margin-bottom:14px;}
    th,td{border:1px solid #e2e8f0; padding:8px; text-align:left;}
    .mono{font-family:monospace;background:#f1f5f9;padding:2px 4px;border-radius:4px;}
    .blocks-grid{display:flex; flex-wrap:wrap; gap:10px;}
    .decoder-block{padding:10px 16px; border:1px solid #cbd5e1; border-radius:8px; background:#fff; cursor:pointer;}
    .decoder-block.active{background:#2563eb; color:#fff;}
    #parameter-details-container{margin-top:16px;}
  </style>
</head>
<body>
<div class="container">
  <h1>ðŸŽ¨ LLM Optimization Explorer</h1>
  <div class="header-intro">
    <p>This page shows a live snapshot of optimization. Left: training stats & formulas. Right: parameters grouped by transformer blocks.</p>
  </div>
  <div id="content">Loading Optimizer Dataâ€¦</div>
</div>

<script>
const ENDPOINT = "/optim";

function fmt(val){if(val==null)return''; if(typeof val==='number')return Number(val.toFixed(8)).toString(); if(Array.isArray(val))return val.join(', '); if(typeof val==='object')return JSON.stringify(val); return String(val);}
function mkRow(k,v){const tr=document.createElement('tr'); const th=document.createElement('th'); th.textContent=k; const td=document.createElement('td'); td.className='mono'; td.textContent=fmt(v); tr.appendChild(th); tr.appendChild(td); return tr;}
function tableFromObject(obj){
  const wrapper=document.createElement('div'); const table=document.createElement('table'); const tbody=document.createElement('tbody');
  if(obj.pretty_name) tbody.appendChild(mkRow('Pretty Name',obj.pretty_name));
  if(obj.name) tbody.appendChild(mkRow('Raw Name',obj.name));
  if(obj.shape) tbody.appendChild(mkRow('Shape',Array.isArray(obj.shape)?obj.shape.join(' Ã— '):obj.shape));
  if(obj.num_params!==undefined) tbody.appendChild(mkRow('Number of Parameters',obj.num_params));
  Object.entries(obj).forEach(([k,v])=>{if(!['name','pretty_name','shape','num_params'].includes(k))tbody.appendChild(mkRow(k,v));});
  table.appendChild(tbody); wrapper.appendChild(table); return wrapper;
}
function flatten(prefix,obj,out){Object.entries(obj||{}).forEach(([k,v])=>{const key=prefix?`${prefix}.${k}`:k; if(v&&typeof v==='object'&&!Array.isArray(v)){flatten(key,v,out);}else{out[key]=v;}}); return out;}
function findAllOptimObjects(root){const found=[]; function walk(node){if(!node||typeof node!=='object')return; if('parameters'in node)found.push(node); if(Array.isArray(node))node.forEach(walk); else Object.values(node).forEach(walk);} walk(root); return found;}

function renderOneOptim(obj,container){
  container.innerHTML=''; const mainLayout=document.createElement('div'); mainLayout.className='main-layout';
  const left=document.createElement('div'); const right=document.createElement('div'); mainLayout.appendChild(left); mainLayout.appendChild(right); container.appendChild(mainLayout);

  // --- LEFT: Optimizer Stats ---
  const statsBox=document.createElement('div'); statsBox.className='info-box'; statsBox.innerHTML='<h2>Optimizer Stats</h2>';
  const general={...(obj.step&&{step:obj.step}),...(obj.lr&&{lr:obj.lr})};
  statsBox.appendChild(tableFromObject(general));
  const grad=flatten('grad',obj.grad||{},{}); if(Object.keys(grad).length) statsBox.appendChild(tableFromObject(grad));
  const adamw=flatten('adamw',obj.adamw||{},{}); if(Object.keys(adamw).length) statsBox.appendChild(tableFromObject(adamw));
  left.appendChild(statsBox);

  // --- LEFT: Update Rule ---
  if(obj.formula){const fbox=document.createElement('div'); fbox.className='info-box'; fbox.innerHTML='<h2>Update Rule</h2><div>'+obj.formula+'</div>'; left.appendChild(fbox); renderMathInElement(fbox);}

  // --- LEFT: Glossary ---
  const gbox=document.createElement('div'); gbox.className='info-box';
  gbox.innerHTML = `
    <h2>ðŸ“˜ Glossary</h2>
    <dl>
        <dt><strong>Optimization</strong></dt>
        <dd>Adjusting model parameters to minimize the loss function.</dd>

        <dt><strong>Gradient</strong></dt>
        <dd>A vector indicating the direction of steepest ascent for the loss.</dd>

        <dt><strong>Learning Rate</strong></dt>
        <dd>Controls the step size during optimization.</dd>

        <dt><strong>AdamW</strong></dt>
        <dd>An adaptive optimization algorithm that maintains an internal state (m and v) for each parameter.</dd>

        <dt><strong>param_norm</strong></dt>
        <dd>L2 norm (magnitude) of the parameterâ€™s weight values. Indicates the scale of the parameter itself.</dd>

        <dt><strong>grad_norm</strong></dt>
        <dd>L2 norm of the gradient for this parameter. Shows how strongly this parameter is being pushed to update.</dd>

        <dt><strong>m_norm</strong></dt>
        <dd>L2 norm of the first-moment estimate (momentum term) used by AdamW to smooth gradients.</dd>

        <dt><strong>v_norm</strong></dt>
        <dd>L2 norm of the second-moment estimate (squared gradient term) used by AdamW to stabilize updates.</dd>
    </dl>`;
  left.appendChild(gbox);

  // --- RIGHT: Parameters ---
  const pbox=document.createElement('div'); pbox.className='info-box'; pbox.innerHTML='<h2>Parameters</h2><p>Click a block to inspect its parameters</p>';
  const grid=document.createElement('div'); grid.className='blocks-grid'; pbox.appendChild(grid);
  const details=document.createElement('div'); details.id='parameter-details-container'; pbox.appendChild(details); right.appendChild(pbox);

  const grouped=new Map(); const nonblock=[]; const re=/transformer\.blocks\.(\d+)\./;
  (obj.parameters||[]).forEach(p=>{const m=p.name? p.name.match(re):null; if(m){const id=m[1]; if(!grouped.has(id))grouped.set(id,[]); grouped.get(id).push(p);} else nonblock.push(p);});
  if(nonblock.length)grouped.set('general',nonblock);
  Array.from(grouped.keys()).sort((a,b)=>a==='general'?-1:b==='general'?1:parseInt(a)-parseInt(b)).forEach(id=>{
    const div=document.createElement('div'); div.className='decoder-block'; div.textContent=id==='general'?'General':`Decoder Block ${id}`; div.dataset.id=id; grid.appendChild(div);
  });

  grid.addEventListener('click',e=>{
    const b=e.target.closest('.decoder-block'); if(!b)return; grid.querySelectorAll('.decoder-block').forEach(x=>x.classList.remove('active')); b.classList.add('active'); details.innerHTML='';
    const params=grouped.get(b.dataset.id)||[]; params.forEach(p=>{const o={name:p.name, pretty_name:p.pretty_name, shape:p.shape, num_params:p.num_params, param_norm:p.param_norm, grad_norm:p.grad_norm, m_norm:p.m_norm, v_norm:p.v_norm}; details.appendChild(tableFromObject(o));});
  });
  if(grid.firstChild) grid.firstChild.click();
}

async function load(){const container=document.getElementById('content'); try{const res=await fetch(ENDPOINT+`?ts=${Date.now()}`); const data=await res.json(); const snaps=findAllOptimObjects(data); renderOneOptim(snaps[0],container);}catch(e){console.error(e); container.textContent="Failed to load data";}}
load();
</script>
</body>
</html>
